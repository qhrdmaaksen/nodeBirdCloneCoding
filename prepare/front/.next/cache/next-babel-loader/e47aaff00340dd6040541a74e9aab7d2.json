{"ast":null,"code":"var __jsx = React.createElement;\nimport React, { useEffect } from 'react'; // Next 에서는 이 구문이 필요가 없다.\n\nimport { useDispatch, useSelector } from 'react-redux';\nimport { END } from 'redux-saga';\nimport axios from 'axios';\nimport AppLayout from '../component/AppLayout';\nimport PostForm from '../component/PostForm';\nimport PostCard from \"../component/PostCard\";\nimport { LOAD_POSTS_REQUEST } from '../reducers/post';\nimport { LOAD_MY_INFO_REQUEST } from '../reducers/user';\nimport wrapper from \"../store/configureStore\";\n\nconst Home = () => {\n  const dispatch = useDispatch();\n  const {\n    me\n  } = useSelector(state => state.user);\n  const {\n    mainPosts,\n    hasMorePosts,\n    loadPostsLoading,\n    retweetError\n  } = useSelector(state => state.post);\n  useEffect(() => {\n    // retweet 실패 시 alert 출력\n    if (retweetError) {\n      alert(retweetError);\n    }\n  }, [retweetError]);\n  /* CSR\r\n  useEffect(() => { // 컴포넌트 디드마운트와 같은 효과 가능 , 뒤에 빈배열만 넣는다면\r\n  \tdispatch({ // 매번 로그인 상태를 복구해주기 위해서 만듬\r\n  \t\ttype: LOAD_MY_INFO_REQUEST,\r\n  \t});\r\n  \tdispatch({\r\n  \t\ttype: LOAD_POSTS_REQUEST,\r\n  \t});\r\n  }, []);*/\n  // 스크롤이 끝까지 내려갔을때 다시 로딩하게하는코드\n\n  /*유즈 이펙트에서 윈도우 addEventListener 를 사용할땐 항상 리턴을 해줘야한다.\r\n  \t\t스크롤했던거 해제해줘야한다, 안그러면 메모리에 쌓여있는다.*/\n\n  useEffect(() => {\n    function onScroll() {\n      // (높이를 나타내는것중)scrollY,clientHeight,scrollHeight 를 많이사용\n      console.log(window.scrollY, document.documentElement.clientHeight, document.documentElement.scrollHeight);\n\n      if (window.scrollY + document.documentElement.clientHeight > document.documentElement.scrollHeight - 300) {\n        if (hasMorePosts && !loadPostsLoading) {\n          var _mainPosts;\n\n          // 기존에 로딩을 하고있을땐 이부분이 실행이안됨, 로딩이 끝나면 실행\n          const lastId = (_mainPosts = mainPosts[mainPosts.length - 1]) === null || _mainPosts === void 0 ? void 0 : _mainPosts.id; // 마지막 게시글의 id\n\n          dispatch({\n            // 다 내리면 그때 새로운 것 로딩\n            type: LOAD_POSTS_REQUEST,\n            lastId\n          });\n        }\n      }\n    }\n\n    window.addEventListener('scroll', onScroll);\n    return () => {\n      window.removeEventListener('scroll', onScroll);\n    };\n  }, [hasMorePosts, loadPostsLoading, mainPosts]);\n  return __jsx(AppLayout, null, me && __jsx(PostForm, null), \" \", mainPosts.map(post => __jsx(PostCard, {\n    key: post.id,\n    post: post\n  })));\n}; //  Home 보다 먼저 실행이 된다 ( browser 가 아닌 front server 쪽에서 실행) (SSR)\n// context 는 요청/응답과 SSR에 관련된 정보가 들어있는 객체이고요\n\n/*(브라우저) 쿠키 프론트서버로 전달 ->  (프론트서버) 전달받은 쿠키 저장해서\r\n백엔드 서버로 요청 -> 백엔드서버 쿠키에 따른 데이터 응답 -> 프론트서버\r\n데이터와 컴포넌트 조합 -> 브라우저*/\n\n\nexport const getServerSideProps = wrapper.getServerSideProps(async context => {\n  // server 쪽에서 실행되면 context.req 가 존재함, 서버쪽 쿠키 전달\n\n  /*getServerSideProps는 프론트 서버에서 실행되는 코드입니다. 사용자들은 많은 수의 브라우저로 접근하지만\r\n  프론트 서버는 하나이므로 axios.defaults.headers.Cookie=쿠키 로 쿠키를 설정하게 되면 프론트 서버에\r\n  이 쿠키가 설정되어 버립니다. 모든 브라우저가 프론트 서버를 거쳐 백엔드\r\n  서버로 요청을 보낼 때 같은 쿠키가 적용되어버리는 것입니다.\t그래서 한 번 설정했다가 요청을 보낸 다음에는\r\n  axios.defaults.headers.Cookie = ''로 비워주는 것입니다.*/\n  const cookie = context.req ? context.req.headers.cookie : '';\n  axios.defaults.headers.Cookie = ''; // 쿠키를 사용하지 않고 요청을 보낼때는 비워줌\n  // cookie 공유 문제를 해결 장치\n\n  if (context.req && cookie) {\n    // 서버일때와 cookie 가 있을때\n    axios.defaults.headers.Cookie = cookie; // 쿠키를 써서 요청을 보낼땐 쿠키를 넣어줌\n  }\n\n  context.store.dispatch({\n    // 매번 로그인 상태를 복구해주기 위해서 만듬\n    type: LOAD_MY_INFO_REQUEST\n  });\n  context.store.dispatch({\n    type: LOAD_POSTS_REQUEST\n  }); // request 가 success 로 바뀌기까지 기다려주기 위한 장치\n\n  context.store.dispatch(END);\n  await context.store.sagaTask.toPromise();\n  console.log('context :: ', context);\n});\nexport default Home;","map":null,"metadata":{},"sourceType":"module"}